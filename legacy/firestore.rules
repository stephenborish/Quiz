rules_version = '2';

/**
 * Firestore Security Rules - Secure Assessment Platform v2.0
 * ===========================================================
 *
 * Schema Overview:
 * ├── sys_admin/
 * │   └── config                    : Global settings (teacher-read only)
 * │   └── global_state              : Current active quiz state
 * ├── authorized_teachers/{email}   : Teacher whitelist (RBAC)
 * ├── quizzes/{quizId}/             : Quiz metadata
 * │   └── questions/{questionId}    : Quiz questions with images
 * ├── sessions/{quizId}/
 * │   └── students/{email}          : Live session state per student
 * └── responses/{quizId}/
 *     └── students/{email}          : Student responses with metacognition
 *
 * Security Model:
 * - Teachers: Verified via authorized_teachers collection (dynamic RBAC)
 * - Students: Scoped access to open quizzes and their own data
 * - Submission Lock: Blocked students cannot write responses
 */

service cloud.firestore {
  match /databases/{database}/documents {

    // ============================================
    // HELPER FUNCTIONS
    // ============================================

    /**
     * Checks if the user is authenticated
     */
    function isAuthenticated() {
      return request.auth != null && request.auth.token.email != null;
    }

    /**
     * Extracts the user's email from the auth token
     */
    function getUserEmail() {
      return request.auth.token.email;
    }

    /**
     * Normalizes email for consistent doc IDs.
     */
    function normalizedEmail() {
      return getUserEmail().lower();
    }

    /**
     * Dynamic RBAC: Checks if the user exists in authorized_teachers collection
     * This is the PRIMARY authorization check for teacher privileges
     */
    function isAuthorizedTeacher() {
      return isAuthenticated() &&
             exists(/databases/$(database)/documents/authorized_teachers/$(normalizedEmail()));
    }

    /**
     * Checks if the user owns the document (email-based)
     */
    function isOwner(email) {
      return isAuthenticated() && normalizedEmail() == email.lower();
    }

    function hasSessionShape(data) {
      return data.keys().hasOnly([
        'email',
        'displayName',
        'status',
        'connectedAt',
        'lastHeartbeat',
        'violations',
        'currentQuestion',
        'progress',
        'lastActive',
        'integrityAlerts'
      ]);
    }

    function hasResponseShape(data) {
      return data.keys().hasOnly([
        'email',
        'quizId',
        'answers',
        'totalQuestions',
        'lastUpdated',
        'completedAt'
      ]);
    }

    /**
     * Checks if a quiz is currently OPEN for students
     */
    function isQuizOpen(quizId) {
      return exists(/databases/$(database)/documents/quizzes/$(quizId)) &&
             get(/databases/$(database)/documents/quizzes/$(quizId)).data.status == 'OPEN';
    }

    /**
     * Checks if a student is blocked in a specific quiz session
     */
    function isStudentBlocked(quizId, email) {
      let sessionPath = /databases/$(database)/documents/sessions/$(quizId)/students/$(email);
      return exists(sessionPath) &&
             get(sessionPath).data.status == 'blocked';
    }

    function quizRosterCourseId(quizId) {
      return get(/databases/$(database)/documents/quizzes/$(quizId)).data.rosterCourseId;
    }

    function isRostered(quizId, email) {
      let rosterCourseId = quizRosterCourseId(quizId);
      return rosterCourseId == null ||
             rosterCourseId == '' ||
             exists(/databases/$(database)/documents/courses/$(rosterCourseId)/roster/$(email));
    }

    /**
     * Validates required fields for response submission
     */
    function hasValidResponseFields() {
      let data = request.resource.data;
      return data.keys().hasAll(['answer', 'confidence', 'submittedAt']) &&
             data.confidence is int &&
             data.confidence >= 1 &&
             data.confidence <= 4;
    }

    // ============================================
    // SYSTEM ADMIN COLLECTION
    // ============================================

    /**
     * sys_admin/{docId} - Global system configuration
     *
     * Documents:
     * - config: Firebase settings, feature flags
     * - global_state: Current active quiz ID, system status
     *
     * Access:
     * - Teachers: Read only (for config)
     * - Students: Read global_state only (to know which quiz is active)
     * - Write: Teachers only
     */
    match /sys_admin/{docId} {
      // Teachers can read all sys_admin documents
      allow read: if isAuthorizedTeacher();

      // Teachers can write to sys_admin
      allow write: if isAuthorizedTeacher();

      // Students can only read global_state to know which quiz is active
      allow read: if isAuthenticated() && docId == 'global_state';
    }

    // ============================================
    // AUTHORIZED TEACHERS COLLECTION (RBAC)
    // ============================================

    /**
     * authorized_teachers/{email} - Teacher whitelist
     *
     * Document Structure:
     * {
     *   email: string,
     *   displayName: string,
     *   role: 'admin' | 'teacher',
     *   addedBy: string,
     *   addedAt: timestamp
     * }
     *
     * Access:
     * - Existing Teachers: Full read/write (can add/remove other teachers)
     * - Students: No access
     *
     * Bootstrap: First teacher must be added via Firebase Console
     */
    match /authorized_teachers/{email} {
      // Only existing authorized teachers can read the whitelist
      allow read: if isAuthorizedTeacher();

      // Only authorized teachers can modify the whitelist
      // This creates a self-governing admin system
      allow write: if isAuthorizedTeacher();

      // Prevent deletion of last admin (optional safety)
      // Note: Additional validation should be in app logic
    }

    // ============================================
    // QUIZZES COLLECTION
    // ============================================

    /**
     * quizzes/{quizId} - Quiz metadata and configuration
     *
     * Document Structure:
     * {
     *   title: string,
     *   description: string,
     *   status: 'DRAFT' | 'OPEN' | 'CLOSED',
     *   createdBy: string (teacher email),
     *   createdAt: timestamp,
     *   updatedAt: timestamp,
     *   settings: {
     *     shuffleQuestions: boolean,
     *     shuffleOptions: boolean,
     *     showResults: boolean
     *   }
     * }
     *
     * Access:
     * - Teachers: Full read/write
     * - Students: Read only if status is 'OPEN'
     */
    match /quizzes/{quizId} {
      // Teachers have full access to all quizzes
      allow read, write: if isAuthorizedTeacher();

      // Students can only read OPEN quizzes
      allow read: if isAuthenticated() &&
                     ((resource.data.rosterCourseId == null || resource.data.rosterCourseId == '')
                      ? (resource.data.status == 'OPEN' || resource.data.status == 'CLOSED')
                      : isRostered(quizId, normalizedEmail()));
    }

    /**
     * quizzes/{quizId}/questions/{questionId} - Quiz questions
     *
     * Document Structure:
     * {
     *   order: number,
     *   text: string,
     *   imageUrl: string (optional),
     *   options: [
     *     { id: string, text: string, imageUrl: string, isCorrect: boolean }
     *   ],
     *   createdAt: timestamp,
     *   updatedAt: timestamp
     * }
     *
     * Access:
     * - Teachers: Full read/write
     * - Students: Read only if parent quiz is OPEN
     */
    match /quizzes/{quizId}/questions/{questionId} {
      // Teachers have full access
      allow read, write: if isAuthorizedTeacher();

      // Students can read questions only if the quiz is OPEN
      allow read: if isAuthenticated() && isQuizOpen(quizId);
    }

    // ============================================
    // SESSIONS COLLECTION (Live Proctoring)
    // ============================================

    /**
     * sessions/{quizId}/students/{email} - Live session state
     *
     * Document Structure:
     * {
     *   email: string,
     *   displayName: string,
     *   status: 'active' | 'blocked' | 'completed',
     *   connectedAt: timestamp,
     *   lastHeartbeat: timestamp,
     *   violations: [
     *     { type: string, timestamp: timestamp, details: string }
     *   ],
     *   currentQuestion: number,
     *   progress: number (0-100)
     * }
     *
     * Access:
     * - Teachers: Full read/write (can unblock, monitor)
     * - Students: Read/write their own document only
     */
    match /sessions/{quizId}/students/{email} {
      // Teachers have full access for proctoring
      allow read, write: if isAuthorizedTeacher();

      // Students can read their own session state
      allow read: if isOwner(email);

      // Students can write to their own session (for heartbeat, violations)
      // This allows the client to update status when a violation occurs
      allow create: if isOwner(email) &&
                       isAuthenticated() &&
                       isQuizOpen(quizId) &&
                       isRostered(quizId, email) &&
                       hasSessionShape(request.resource.data) &&
                       request.resource.data.email == normalizedEmail() &&
                       request.resource.data.status == 'active' &&
                       request.resource.data.progress == 0 &&
                       request.resource.data.currentQuestion == 1 &&
                       request.resource.data.violations is list;

      allow update: if isOwner(email) &&
                       isAuthenticated() &&
                       isQuizOpen(quizId) &&
                       isRostered(quizId, email) &&
                       hasSessionShape(request.resource.data) &&
                       request.resource.data.email == normalizedEmail() &&
                       request.resource.data.email == resource.data.email &&
                       request.resource.data.progress >= resource.data.progress &&
                       request.resource.data.currentQuestion >= resource.data.currentQuestion &&
                       request.resource.data.violations.size() >= resource.data.violations.size() &&
                       resource.data.status != 'blocked' &&
                       (request.resource.data.status == resource.data.status ||
                        request.resource.data.status == 'blocked' ||
                        (resource.data.status == 'invited' && request.resource.data.status == 'active'));
    }

    // ============================================
    // RESPONSES COLLECTION
    // ============================================

    /**
     * responses/{quizId}/students/{email} - Student submissions
     *
     * Document Structure:
     * {
     *   email: string,
     *   quizId: string,
     *   answers: {
     *     [questionId]: {
     *       answer: string,
     *       isCorrect: boolean,
     *       confidence: number (1-4),
     *       answeredAt: timestamp
     *     }
     *   },
     *   totalScore: number,
     *   totalQuestions: number,
     *   completedAt: timestamp,
     *   violationLog: array
     * }
     *
     * Access:
     * - Teachers: Full read/write (for grading)
     * - Students: Write their own (if not blocked), read after completion
     * - CRITICAL: Blocked students CANNOT write
     */
    match /responses/{quizId}/students/{email} {
      // Teachers have full access for grading and review
      allow read, write: if isAuthorizedTeacher();

      // Students can read their own responses (after submission)
      allow read: if isOwner(email);

      // CRITICAL SECURITY RULE: Submission Lock
      // ========================================
      // Students can ONLY write if:
      // 1. They own the document
      // 2. The quiz is OPEN
      // 3. They are NOT blocked in the session
      //
      // This server-side enforcement prevents:
      // - Console hacks trying to submit after being blocked
      // - Inspect Element attacks on client-side locks
      // - Any client bypass attempts
      allow create: if isOwner(email) &&
                       isAuthenticated() &&
                       isQuizOpen(quizId) &&
                       isRostered(quizId, email) &&
                       !isStudentBlocked(quizId, email) &&
                       hasResponseShape(request.resource.data) &&
                       request.resource.data.email == normalizedEmail() &&
                       request.resource.data.quizId == quizId &&
                       request.resource.data.answers is map;

      allow update: if isOwner(email) &&
                       isAuthenticated() &&
                       isQuizOpen(quizId) &&
                       isRostered(quizId, email) &&
                       !isStudentBlocked(quizId, email) &&
                       hasResponseShape(request.resource.data) &&
                       request.resource.data.email == normalizedEmail() &&
                       request.resource.data.quizId == quizId &&
                       request.resource.data.email == resource.data.email &&
                       request.resource.data.quizId == resource.data.quizId &&
                       request.resource.data.answers is map &&
                       request.resource.data.answers.keys().hasAll(resource.data.answers.keys()) &&
                       request.resource.data.totalQuestions == resource.data.totalQuestions &&
                       resource.data.completedAt == null &&
                       (request.resource.data.completedAt == null || request.resource.data.completedAt is timestamp);
    }

    match /courses/{courseId} {
      allow read, write: if isAuthorizedTeacher();
    }

    match /courses/{courseId}/roster/{email} {
      allow read, write: if isAuthorizedTeacher();
    }

    // ============================================
    // AUDIT LOG COLLECTION
    // ============================================

    /**
     * audit_log/{logId} - Immutable audit trail
     *
     * Document Structure:
     * {
     *   email: string,
     *   action: string,
     *   quizId: string,
     *   timestamp: timestamp,
     *   details: map,
     *   ipHash: string (for privacy)
     * }
     *
     * Access:
     * - Teachers: Full read, append-only write
     * - Students: Append-only (create their own entries)
     */
    match /audit_log/{logId} {
      // Teachers can read all audit logs
      allow read: if isAuthorizedTeacher();

      // Teachers can create audit entries
      allow create: if isAuthorizedTeacher();

      // Students can only create entries for themselves (append-only)
      allow create: if isAuthenticated() &&
                       request.resource.data.email == normalizedEmail();

      // No updates or deletes allowed - immutable log
      allow update, delete: if false;
    }

    // ============================================
    // ANALYTICS COLLECTION (Teacher-Only)
    // ============================================

    /**
     * analytics/{quizId} - Aggregated quiz analytics
     *
     * Stores pre-computed analytics for "The Matrix" view
     */
    match /analytics/{quizId} {
      // Only teachers can read/write analytics
      allow read, write: if isAuthorizedTeacher();
    }

    // ============================================
    // DEFAULT DENY RULE
    // ============================================

    /**
     * Catch-all: Deny access to any undefined collections
     * Security best practice - explicit deny by default
     */
    match /{document=**} {
      allow read, write: if false;
    }
  }
}
